### 深浅拷贝以及集合

#### 1.集合

集合中不含有重复的元素，而且列表中的元素没有顺序，所以集合的应用场景有一下两点：1.将列表中的元素去重.2.进行一些数字的操作，比如交集，并集，差集……

+ 集合的创建，以及增删改查

集合没有特定的用来修改的方法或是函数，可以利用remove方法将需要修改的元素删除，再利用update函数进行添加来达到修改的目的

```python
set1=set()			#创建一个空的集合，注意，空集合的表示形式是set（），{}表示的是空字典
set2=set('aleihf')
set3=set((1,2,3,4))
set4=set({1,2,3,4})			#以上三种方法均可以迭代创建出一个集合

set1.add(1)				#在集合中添加一个元素
set1.update((1,2,4,5,6))		#在集合中迭代添加元素

set1.pop()				#在集合中随机删除一个元素
set1.remove(1)			#指定删除一个元素
del set1				#将整个集合删除
set1.clear()			#清空集合中元素


```

+ 集合与列表的转化以及交并差集的应用

```python
li=[1,1,1,1,2,4,5,8,6,4,8,5,7]
set1=set(li)
li=list(set1)			#打印的结果为[1, 2, 4, 5, 6, 7, 8]，其实是无序的，有序需要排列

set1={1,2,3,4,5}
set2={4,5,6,7,8}
set3=set1&set2
set4=set1|set2
set5=set1-set2				#set1独有的元素
set6=set1^set2				#相当于并集减去交集
```

#### 2.深浅拷贝

##### 首先，正如我所想，python的列表以及字典还有元组中，存储的都是数据的地址，但是python是一门高级语言，我们不用对地址进行操作，所以我们通过id函数看到的地址其实是一些虚假的地址（个人猜测可能是通过哈希函数等进行转化后的结果），我们不能通过这个地址进行操作，但是我们可以通过地址进行判等。

```python
l1=[1,2,3]
l2=[1,2,3]
li==l2					#这里是对值进行判等
id(l1)==id(l2)			#这里是对地址进行判等
```

+ ##### 直接使用==是对值进行判等，使用id（）函数是对地址进行判等，这里就要提到可更改类型（不可哈希类型）和不可更改类型（可哈希类型）。

  + ##### 可哈希类型（不可更改类型）：int ,str,bool,tuple

    ##### 这些类型在创建时会拥有一个地址，当其中的值被更改时，就会更换地址

  + ##### 不可哈希类型（可更改类型）：比如set，list，dict……都属于可更改类型

    ##### 这些类型在创建时会拥有一个地址，对其进行增删改查不会影响其地址（个人猜测类似于c++中的迭代器，当其中存储的数值达到一定程度时，会进行地址的更改，而且内部有一套算法对这个迭代器的大小进行维护）

```python
l1=[1,2,3,4,5,6]
l2=[3,4,5,l1]
l1.append(555)				#此时由于地址的公用关系，所以l2中的l1列表也会增加555
```

+ 深浅拷贝

```python
l1=[1,2,3,[4,5,6]]
l2.copy(l1)				#此时就是进行了浅拷贝，当l1[3]进行改变时，l2同时也会进行改变
						#其实就是l2无脑将l1中所有数据的地址拷贝到自己的空间中
    
    
import copy
l2=copy.deepcopy(l1)	#这种深拷贝原本应该是为每一个数据分配一个新的地址，但是从空间优化的							#角度考虑，因为不可更改的数据的只读性质，没有必要再开辟空间，所以							#只为不可更改的数据重新开辟空间
```



##### 3.同一模块以及不同模块对于数据的存储方式

+ 同一代码块

  在同一代码块中，对于不可更改的数据，所有的int类型，几乎所有的str类型，bool类型（不包含元组即tuple类型），内部都有一个字典维护，当对象第一次创建时，会为其分配内存，但是当第二次出现时，直接指向该地址即可，不会再次分配内存

  ```python
  i1=100
  i2=100
  i3=100				#因为都是int类型的100，所以i1,i2,i3这三个变量指向的地址是相同的
  ```

+ 不同的代码块

  不同的代码块，有一个小数据池进行维护，只有-5~255，以及满足规则的字符串才会公用一块地址，其他情况都会重新分配地址





